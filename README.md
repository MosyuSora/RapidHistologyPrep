# Rapid Histology Prep System

This project is a small & rapid histology preparation system, an Arduino-based system integrating precise temperature control (PID algorithm) automated fluid management. This is a bare-metal development task (no real-time operating system), but in the design we fully consider the real-time and multitasking nature of the whole system. This project is currently in the prototype stage, and more robust design and human-machine interaction optimization is needed in the future.

## Hardware Components
- **Main Controller**
  - Arduino Nano
  - Peripheral circuit driving board

- **Heating Module**
  - 100KΩ NTC Thermistor Sensor
  - PWM-controlled heater

- **Fluid Pump**
  - 2 fluid stepper pump: inlet and outlet
- **Wax Cooler**
  - A Peltier module with a heat-sink fan. No controlling.

- **Indicators**
  - 3-color RGB LED (Red/Green/Blue)
- **HMI**
  - A Nextion serial LCD screen.

- **Power Supply**
  - 12V 10A 3-socket DC PSU(for heater, cooler)
  - 5V 3A DC-DC convertor(for control board)


## Pin Configuration
| Component      | Pins    |
| -------------- | ------- |
| Inlet Stepper  | 4,5,6   |
| Outlet Stepper | 7,15,16 |
| Heater PWM     | 10      |
| Cooler PWM     | 11      |
| Thermistor     | A3      |
| Control Button | 2       |
| Blue LED       | 8       |
| Green LED      | 12      |
| Red LED        | 13      |

## Design
The following are the core functions and their implementation of this program. If debugging and calibration is required, it is helpful for you to read this section carefully.

###   Close-loop Temperature Control System

#### Controller

Because heating system has complicated frequency response, we use a **discrete PID controller** to control heating.
$$
u[k] = K_p e[k] + K_i T_s \sum_{i=0}^{k} e[i] + K_d \frac{e[k] - e[k-1]}{T_s}
$$
Where Ts is sampling period, is 1s in our design. And for PID parameters:
$$
K_{p}=15, K_{i}=0.02,K_d=0.5
$$
We conducted several time-consuming experiments to obtain these parameters. And they are proved to be effective. If you are debugging, I don't recommend to adjust them casually !

And to avoid integral wind-up, we only activate integral controller when
$$
|e[k]| < 1.0
$$
And to get duty-ratio output, final step of controller is:
$$
d[k] = \begin{cases} 
0, & u[k] < 0 \\
u[k], & 0 \leq u[k] \leq 255 \\
255, &  u[k] > 255
\end{cases}
$$




#### Sensor

For sensor we designed a NTC thermistor sampling circuit with a passive low-pass filter to obtain a stable temperature curve. You may click [schematic file](https://github.com/MosyuSora/RapidHistologyPrep/blob/main/Schematic%20Prints.pdf) to check the detail.

##### NTC Thermistor Sampling

Here is how the temperature is obtained based on selected thermistor.

- Calculate the voltage divided by the thermistor

$$
V_{\text{thm}} = \left(\frac{\text{V}_{read}}{2^{10}-1}\right) \times V_{\text{Supply}}
$$

- Calculate resistance of thermistor

$$
R_{\text{thermistor}} = R_{\text{known}} \times \frac{V_{\text{thm}}}{V_{known}}
$$

​	Where 
$$
V_{known} = V_{\text{Supply}} - V_{\text{read}}
$$
​	is voltage on known resistor

- Using *Steinhart-Hart formula* to calculate temperature. For coefficient you may check datasheet for nominal temperature and resistance for thermistor.   *Note: T is in kelvin*
  $$
  \frac{1}{T}- \frac{1}{T_{\text{nominal}}}={\frac{1}{B} }\ln\left(\frac{R_{\text{thermistor}}}{R_{\text{nominal}}}\right)
  $$

- 

At `25℃` our thermistor has `R = 100Kohm` and `B = 3950 K`.

##### Filtering

###### Analog Filter

During testing, a considerable electro-magnetic interference was observed (Perhaps generated by H-bridge module and DC-DC converter). As temperature signal has low frequency, a passive low-pass filter is adding to the circuit.

The amplitude response of our filter is:
$$
|H(w)|=\frac{1}{\sqrt{1+(\frac{\omega}{\omega_{0}})^2}}
$$
where 
$$
\omega_{0}=\frac{1}{RC}=30.30 rad/s,f=\frac{\omega_0}{2\pi}=4.82Hz
$$
So for signals that frequency > 4.82 Hz will get filtered.

###### Digital Filter

Also a median digital filter is adding to code to get precise temperature reading. For this, we repeat sampling for 15 times with 2ms interval. The final temperature could be described as:


$$
t_r[n]=median({t[n−14],t[n−13],…,t[n]})
$$
We use bubbling sorting to find median. 

#### Actuator

The heating subsystem uses a H-bridge module (MOSFET, large current) to control a cartridge heater. Use `analogWrite(PIN,[0~255])` to generate a 0~100% duty ratio rectangular wave to limit the power of cartridge heater. Below is an instruction for H-bridge module:

| IN1    | IN2    | OUTPUT                  |
| ------ | ------ | ----------------------- |
| ON/PWM | OFF    | (+)\PWM+                |
| OFF    | ON/PWM | (-)\PWM-                |
| ON     | ON     | INSTANT STOP(for motor) |
| OFF    | OFF    | 0                       |



### Open-loop Controlled Fluid Pump

In this project we use a open-loop approach to control reagent volume pumping in. No flowmeter is applied. This would be a potential point to be upgraded.

#### Volume-step Relation of Stepper Pump

To control stepper to pump given volume of fluid, we could follow the relation below:
$$
n_{steps}={\frac{5*800}{3}}V_{fluid}
$$


#### Dead-volume and backflow

For each pumping of each reagent, because there's distance between container and tissue chamber, we should calculate dead-volume between them. This could be determined as:
$$
V_{dead}=\pi{(\frac{D_i}{2})}^2L
$$
Where D is inner diameter of tube. And L is tube length.

Besides, backflow is necessary in the fluid management task. It refers to the intentional reversal of fluid flow to prevent leakage, ensure precise volume control, and eliminate residual liquid or air bubbles. Therefore, you can find related logic in the fluid control implementation.

### Status Indicators

- **Green LED**: Power status (always on)

- **Red LED**: Heating temperature setpoint indicator
  
  - Slow blink (1Hz): 40°C mode
  - Fast blink (5Hz): 60°C mode
  
- **Blue LED**: Temperature setpoint reached/Push button is ready

  - 1st on - press button

  - 2nd on - add wax

  - 3rd on - press button

  - 4th on - add wax

    ......


## Operation Guide

1. Connect components per pin configuration
2. Green LED illuminates at power-on indicating readiness. Blue LED is on indicating pushbutton is ready.
3. Press button to initiate 40°C heating sequence
4. Automatic process flow:
   - 40°C achieved → 8-stage fluid handling
   - Fluid cycles completed → Heat to 60°C for 20min
   - Auto-cool to 40°C for standby



## Code Styling

To fully understand the grounded logic of this project, it's better for readers to carefully follow these coding styles. Some of them are mandatory.

### Layered Logic

This project follows a **layered, object-oriented** coding style. When adding new features, stick to these key rules:

- ​	**Keep `loop()` and `setup()` clean—don’t stuff them with logic!** Instead, wrap your logic in functions and call them. Here’s an example:

  ​	

```cpp
/*WRONG:*/
void loop(){
    ....//existing logic
    if(digitalRead(BOTTON_PIN)==0){
        digialWrite(LED_PIN,HIGH);
    }else{
        digitalWrite(LED_PIN,LOW);
    }
}

/*CORRECT:*/
void LED(){
    if(digitalRead(BOTTON_PIN)==0){
        digitalWrite(LED_PIN,HIGH);
    }else{
        digitalWrite(LED_PIN,LOW);
    }
}
void loop(){
    ....//existing logic
    LED();
}	
```

- **No global variable. Wrap them in global namespace. Relative functions share a same namespace.** For necessary global variables and global objects, we package them in namespace. Here is an example:

  ```cpp
  /*WRONG:*/
  const float PI = 3.14159;
  const int STEP_CONSTANT = 114514;
  float calculateVolume(float*radius,float* length){
      return PI*pow(radius,2)*length;
  }
  void pumpReagent(){
      ...//somelogic
      int volume = (int)ceil(caculateVolume(0.05.100));
      int pumpSteps = volume*STEP_CONSTANT;
      ...//somelogic
  }
  
  /*CORRECT:*/
  namespace pumpPara = {
      const float PI = 3.14159;
  	const int STEP_CONSTANT = 114514;
      //I don't recommend to write functions in namespace
  };
  float calculateVolume(float*radius,float* length){
      return (pumpPara::PI)*pow(radius,2)*length;//Use :: to call
  }
  void pumpReagent(){
      using namespace pumpPara;//Not recommended!
      ...//somelogic
      int volume = (int)ceil(caculateVolume(0.05.100));
      int pumpSteps = volume*STEP_CONSTANT;
      ...//somelogic
  }
  ```

  

- **Use class to packaging duplicatable structures. **For example, **drivers**, **data structures** and **algorithm implementations**. Currently, the driver of stepper motor, a controller based on PID algorithm and a median filter based on bubbling sorting algorithm were packaged to classes for easy calling, debugging and duplication. Here's an example:

  ```cpp
  /*NOT WRONG, just not recommended*/
  namespace ledPara{
    const int bilinkinterval = 3*1000;  
    const int ledPin = LED_PIN;
    bool ledState = TRUE;
  };
  void ledControl(){
      time = millis()
      if(time-lastToggle>=interval){
          ledPara::ledState=!(ledPara::ledState);
          lastToggle = time;
          digitalWrite(ledPara::ledPin,ledPara::ledState);
      }
  }
  /*Recommended*/
  //LED has different templates, like on-off led, blink led and breathing led, etc.So it is
  //a better approach to use "inheritage".
  class led {
      private:
      int ledPin;
      bool ledState;
      public:
      led(int led_pin,int led_state):ledPin(led_pin),ledState(led_state){}
      void ledSet(bool state){
          digitalWrite(ledPin,state);
          ledState = state;
      }
  };
  class ledBlink:: public led{
      private:
      float blinkSeconds;
      int lastToggle;
      public:
      ledBlink(int led_pin,int led_state,float blink_seconds):ledPin(led_pin),ledState(led_state),
      blinkSeconds(blink_seconds){}
      void ledBlink(){
      	time=millis();
          interval=(int)ceil(blinkSeconds*1000)
          if(time-lastToggle>=interval){
              ledState=!ledState;
              ledSet(ledState);
              lastToggle = time;
     		 }
      }
      void setBlinkTime(float blinkTime):blinkSeconds(blinkTime){}
  };
  namespace ledPara {
      led yellowLED = led(LED_YELLOW,LOW);
      ledBlink blueLED = ledBlink(LED_BLUE,LOW,1);
  };
  void controlLED(){
      ledPara::blueLED.ledBlink();
      ledPara::yellowLED.ledSet(heaterPara::ready);
  }
  
  ```

### Non-blocking Logics

- **Avoid using `for` and `while`. Use `switch-case` and state machine(SM).** You may feel comfortable using loops while you coding in your software design course project. Even for single task project running on MCU , it works perfectly. However, if this style were applied to a multi-tasks real time embedded system, that would be horrible. CPU couldn't do anything else but finish your loops and other processes have to wait for it. The motor would not rotate, led would not blink and heater would cool down.



- **No `delay()`!!! Use `millis()`!!!**Same as `for` loop.`delay()`will cause serious blocking issue. Instead we can polling the current CPU time from embedded timer(After 32day it will reset). For Arduino we get time from `millis()` for milliseconds and `micros()` for microseconds.

  Here is an example showing how to write a non-blocking code:

 

```cpp
/*SERIOUSLY WRONG!!*/
void badExample() {
    for (int i = 0; i < 4; i++) {
        digitalWrite(LED_PIN, HIGH);
        delay(5000);
        digitalWrite(LED_PIN, LOW);
        delay(5000);
    }
}
/*CORRECT*/
namespace ledPara{
    enum class ledState {
        BLINK_0, // LED OFF
        BLINK_1, // LED ON 5s
        BLINK_2, // LED OFF 5s
        BLINK_3  // LED ON 5s
    }state =0

    unsigned long previousMillis = 0;
    long interval = 5000;
};
void ledSwithing(){
    unsigned long currentMillis = millis();
	using namespace ledPara
    if (currentMillis - previousMillis >= interval) {
        previousMillis = currentMillis;

        switch (state) {
            case ledState::BLINK_0:
                digitalWrite(LED_PIN, LOW);
                state = ledState::BLINK_1;
                break;
            case ledState::BLINK_1:
                digitalWrite(LED_PIN, HIGH);
                state = ledState::BLINK_2;
                break;
            case ledState::BLINK_2:
                digitalWrite(LED_PIN, LOW);
                state = ledState::BLINK_3;
                break;
            case ledState::BLINK_3:
                digitalWrite(LED_PIN, HIGH);
                state = ledState::BLINK_0;
                break;
        }
    }
}

```

### Other Coding Style

- **Variable names should use lower camel case ** , except for macros and state machine states.

```cpp
/*WRONG*/
int rapid_hist_system = 0;//snake case
int RapidHistSystem = 0;//upper camel case
/*CORRECT*/
int rapidHistSystem = 0;
```

- **Use macro definition** to assist code inspections. Especially all **PIN definition** must be set in macro definition.

```cpp
#define LED_PIN 18
#define ADC_PIN A2
#define FILTER_SIZE 16
```





## Software Architecture

### Layer Structure

loop()  # Main entry point (Top-Level Logic)
│
├── Functions & Utility Functions  # Core logic implementation
│
├── Global Namespaces  # Encapsulated Global Variables
│
└── Classes (Lowest Level - Hardware Abstraction)
    ├── Divers
    ├── Controllers
    └── Data Processors



### Core Blocks

#### Classes

- `MedianFilter`: Analog signal conditioning
- `PIDController`: Thermal regulation PID controller
- `stepMotor`: Stepper motor driver

#### Namespaces

- `heatingPara`:Global variables for heating
- `fluidPara`:Global variables for pump
- `ledPara`:Global variables for led and button

#### Functions

Here are functions and utility functions categorized in different tasks. For **`boldFunctions()`**, it means they are functions involving in main `loop()`

##### Heating

- **`heatingControl()`**: Key functions of temperature control. Process state transfer and heater control.
- `tempSetInit()`: When press pushbutton. Initialize temperature state machine
- `readTemperature()`: Read temperature & filtering. Print information to serial port.

 

##### Fluid

- **`processFluid()`**: Key functions of fluid control. Process state transfer and motor control.
- **`motorControl()`**:Update stepper in real time.
- `startFluidCycle()`: When finish heating to 40 ℃ . Initialize fluid state machine
- `calculateSteps()`Calculate steps base on step-volume relations

##### LED&Pushbutton

- **`handleButton()`**: Only valid when it is ready(blue led on). Handle the pushbutton.
- **`updateLEDStatus()`**: Drive LED.

### Flow Chart

Here is a flowchart describing transfer of state for each state machine. This will help you understand how `processFluid()` and `heatingControl()`works

![Image](https://github.com/MosyuSora/RapidHistologyPrep/blob/main/flowChart.png?raw=true)

## Teams and Contribution

Luyu Yang - Code structuring, Control system design, Circuit design, PCB design, GUI design, Coding, Debugging, and Documenting

Wei Zhang - Coding, Testing, Debugging, and Documenting



## License

MIT License - Free for modification/use with original author attribution